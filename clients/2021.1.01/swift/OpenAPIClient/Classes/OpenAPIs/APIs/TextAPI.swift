//
// TextAPI.swift
//
// Generated by openapi-generator
// https://openapi-generator.tech
//

import Foundation



open class TextAPI {
    /**
     Text - Compare strings
     
     - parameter stringComparison: (body)  (optional)
     - parameter apiResponseQueue: The queue on which api response is dispatched.
     - parameter completion: completion handler to receive the data and the error objects
     */
    open class func compareStrings(stringComparison: InputStringComparison? = nil, apiResponseQueue: DispatchQueue = OpenAPIClientAPI.apiResponseQueue, completion: @escaping ((_ data: OutputString?,_ error: Error?) -> Void)) {
        compareStringsWithRequestBuilder(stringComparison: stringComparison).execute(apiResponseQueue) { result -> Void in
            switch result {
            case let .success(response):
                completion(response.body, nil)
            case let .failure(error):
                completion(nil, error)
            }
        }
    }

    /**
     Text - Compare strings
     - POST /CompareStrings
     - Perform a comparison of two strings
     - API Key:
       - type: apiKey X-IBM-Client-Id 
       - name: apiKeyHeader
     - parameter stringComparison: (body)  (optional)
     - returns: RequestBuilder<OutputString> 
     */
    open class func compareStringsWithRequestBuilder(stringComparison: InputStringComparison? = nil) -> RequestBuilder<OutputString> {
        let path = "/CompareStrings"
        let URLString = OpenAPIClientAPI.basePath + path
        let parameters = JSONEncodingHelper.encodingParameters(forEncodableObject: stringComparison)

        let url = URLComponents(string: URLString)

        let requestBuilder: RequestBuilder<OutputString>.Type = OpenAPIClientAPI.requestBuilderFactory.getBuilder()

        return requestBuilder.init(method: "POST", URLString: (url?.string ?? URLString), parameters: parameters, isBody: true)
    }

    /**
     Text - Contains string
     
     - parameter stringContains: (body)  (optional)
     - parameter apiResponseQueue: The queue on which api response is dispatched.
     - parameter completion: completion handler to receive the data and the error objects
     */
    open class func containsString(stringContains: InputStringContains? = nil, apiResponseQueue: DispatchQueue = OpenAPIClientAPI.apiResponseQueue, completion: @escaping ((_ data: OutputString?,_ error: Error?) -> Void)) {
        containsStringWithRequestBuilder(stringContains: stringContains).execute(apiResponseQueue) { result -> Void in
            switch result {
            case let .success(response):
                completion(response.body, nil)
            case let .failure(error):
                completion(nil, error)
            }
        }
    }

    /**
     Text - Contains string
     - POST /ContainsString
     - Determine if a string contains another string
     - API Key:
       - type: apiKey X-IBM-Client-Id 
       - name: apiKeyHeader
     - parameter stringContains: (body)  (optional)
     - returns: RequestBuilder<OutputString> 
     */
    open class func containsStringWithRequestBuilder(stringContains: InputStringContains? = nil) -> RequestBuilder<OutputString> {
        let path = "/ContainsString"
        let URLString = OpenAPIClientAPI.basePath + path
        let parameters = JSONEncodingHelper.encodingParameters(forEncodableObject: stringContains)

        let url = URLComponents(string: URLString)

        let requestBuilder: RequestBuilder<OutputString>.Type = OpenAPIClientAPI.requestBuilderFactory.getBuilder()

        return requestBuilder.init(method: "POST", URLString: (url?.string ?? URLString), parameters: parameters, isBody: true)
    }

    /**
     Text - Convert case
     
     - parameter caseConversion: (body)  (optional)
     - parameter apiResponseQueue: The queue on which api response is dispatched.
     - parameter completion: completion handler to receive the data and the error objects
     */
    open class func convertCase(caseConversion: InputCaseConversion? = nil, apiResponseQueue: DispatchQueue = OpenAPIClientAPI.apiResponseQueue, completion: @escaping ((_ data: OutputString?,_ error: Error?) -> Void)) {
        convertCaseWithRequestBuilder(caseConversion: caseConversion).execute(apiResponseQueue) { result -> Void in
            switch result {
            case let .success(response):
                completion(response.body, nil)
            case let .failure(error):
                completion(nil, error)
            }
        }
    }

    /**
     Text - Convert case
     - POST /ConvertCase
     - Convert string to upper, lower or title case
     - API Key:
       - type: apiKey X-IBM-Client-Id 
       - name: apiKeyHeader
     - parameter caseConversion: (body)  (optional)
     - returns: RequestBuilder<OutputString> 
     */
    open class func convertCaseWithRequestBuilder(caseConversion: InputCaseConversion? = nil) -> RequestBuilder<OutputString> {
        let path = "/ConvertCase"
        let URLString = OpenAPIClientAPI.basePath + path
        let parameters = JSONEncodingHelper.encodingParameters(forEncodableObject: caseConversion)

        let url = URLComponents(string: URLString)

        let requestBuilder: RequestBuilder<OutputString>.Type = OpenAPIClientAPI.requestBuilderFactory.getBuilder()

        return requestBuilder.init(method: "POST", URLString: (url?.string ?? URLString), parameters: parameters, isBody: true)
    }

    /**
     Text - Decode string
     
     - parameter stringInput: (body)  (optional)
     - parameter apiResponseQueue: The queue on which api response is dispatched.
     - parameter completion: completion handler to receive the data and the error objects
     */
    open class func decodeString(stringInput: InlineObject? = nil, apiResponseQueue: DispatchQueue = OpenAPIClientAPI.apiResponseQueue, completion: @escaping ((_ data: OutputString?,_ error: Error?) -> Void)) {
        decodeStringWithRequestBuilder(stringInput: stringInput).execute(apiResponseQueue) { result -> Void in
            switch result {
            case let .success(response):
                completion(response.body, nil)
            case let .failure(error):
                completion(nil, error)
            }
        }
    }

    /**
     Text - Decode string
     - POST /DecodeString
     - Decode a string encoded with Base64 encoding
     - API Key:
       - type: apiKey X-IBM-Client-Id 
       - name: apiKeyHeader
     - parameter stringInput: (body)  (optional)
     - returns: RequestBuilder<OutputString> 
     */
    open class func decodeStringWithRequestBuilder(stringInput: InlineObject? = nil) -> RequestBuilder<OutputString> {
        let path = "/DecodeString"
        let URLString = OpenAPIClientAPI.basePath + path
        let parameters = JSONEncodingHelper.encodingParameters(forEncodableObject: stringInput)

        let url = URLComponents(string: URLString)

        let requestBuilder: RequestBuilder<OutputString>.Type = OpenAPIClientAPI.requestBuilderFactory.getBuilder()

        return requestBuilder.init(method: "POST", URLString: (url?.string ?? URLString), parameters: parameters, isBody: true)
    }

    /**
     Text - Encode string
     
     - parameter stringInput: (body)  (optional)
     - parameter apiResponseQueue: The queue on which api response is dispatched.
     - parameter completion: completion handler to receive the data and the error objects
     */
    open class func encodeString(stringInput: InputString? = nil, apiResponseQueue: DispatchQueue = OpenAPIClientAPI.apiResponseQueue, completion: @escaping ((_ data: OutputString?,_ error: Error?) -> Void)) {
        encodeStringWithRequestBuilder(stringInput: stringInput).execute(apiResponseQueue) { result -> Void in
            switch result {
            case let .success(response):
                completion(response.body, nil)
            case let .failure(error):
                completion(nil, error)
            }
        }
    }

    /**
     Text - Encode string
     - POST /EncodeString
     - Encode a string using Base64 encoding
     - API Key:
       - type: apiKey X-IBM-Client-Id 
       - name: apiKeyHeader
     - parameter stringInput: (body)  (optional)
     - returns: RequestBuilder<OutputString> 
     */
    open class func encodeStringWithRequestBuilder(stringInput: InputString? = nil) -> RequestBuilder<OutputString> {
        let path = "/EncodeString"
        let URLString = OpenAPIClientAPI.basePath + path
        let parameters = JSONEncodingHelper.encodingParameters(forEncodableObject: stringInput)

        let url = URLComponents(string: URLString)

        let requestBuilder: RequestBuilder<OutputString>.Type = OpenAPIClientAPI.requestBuilderFactory.getBuilder()

        return requestBuilder.init(method: "POST", URLString: (url?.string ?? URLString), parameters: parameters, isBody: true)
    }

    /**
     Text - Generate GUID
     
     - parameter generateUniqueID: (body)  (optional)
     - parameter apiResponseQueue: The queue on which api response is dispatched.
     - parameter completion: completion handler to receive the data and the error objects
     */
    open class func generateGuid(generateUniqueID: InputGenerateUniqueID? = nil, apiResponseQueue: DispatchQueue = OpenAPIClientAPI.apiResponseQueue, completion: @escaping ((_ data: OutputString?,_ error: Error?) -> Void)) {
        generateGuidWithRequestBuilder(generateUniqueID: generateUniqueID).execute(apiResponseQueue) { result -> Void in
            switch result {
            case let .success(response):
                completion(response.body, nil)
            case let .failure(error):
                completion(nil, error)
            }
        }
    }

    /**
     Text - Generate GUID
     - POST /GenerateGuid
     - Generate a globally unique identifier
     - API Key:
       - type: apiKey X-IBM-Client-Id 
       - name: apiKeyHeader
     - parameter generateUniqueID: (body)  (optional)
     - returns: RequestBuilder<OutputString> 
     */
    open class func generateGuidWithRequestBuilder(generateUniqueID: InputGenerateUniqueID? = nil) -> RequestBuilder<OutputString> {
        let path = "/GenerateGuid"
        let URLString = OpenAPIClientAPI.basePath + path
        let parameters = JSONEncodingHelper.encodingParameters(forEncodableObject: generateUniqueID)

        let url = URLComponents(string: URLString)

        let requestBuilder: RequestBuilder<OutputString>.Type = OpenAPIClientAPI.requestBuilderFactory.getBuilder()

        return requestBuilder.init(method: "POST", URLString: (url?.string ?? URLString), parameters: parameters, isBody: true)
    }

    /**
     Text - Generate hash
     
     - parameter generateHash: (body)  (optional)
     - parameter apiResponseQueue: The queue on which api response is dispatched.
     - parameter completion: completion handler to receive the data and the error objects
     */
    open class func generateHash(generateHash: InputGenerateHash? = nil, apiResponseQueue: DispatchQueue = OpenAPIClientAPI.apiResponseQueue, completion: @escaping ((_ data: OutputString?,_ error: Error?) -> Void)) {
        generateHashWithRequestBuilder(generateHash: generateHash).execute(apiResponseQueue) { result -> Void in
            switch result {
            case let .success(response):
                completion(response.body, nil)
            case let .failure(error):
                completion(nil, error)
            }
        }
    }

    /**
     Text - Generate hash
     - POST /GenerateHash
     - Generate a hash value from a string
     - API Key:
       - type: apiKey X-IBM-Client-Id 
       - name: apiKeyHeader
     - parameter generateHash: (body)  (optional)
     - returns: RequestBuilder<OutputString> 
     */
    open class func generateHashWithRequestBuilder(generateHash: InputGenerateHash? = nil) -> RequestBuilder<OutputString> {
        let path = "/GenerateHash"
        let URLString = OpenAPIClientAPI.basePath + path
        let parameters = JSONEncodingHelper.encodingParameters(forEncodableObject: generateHash)

        let url = URLComponents(string: URLString)

        let requestBuilder: RequestBuilder<OutputString>.Type = OpenAPIClientAPI.requestBuilderFactory.getBuilder()

        return requestBuilder.init(method: "POST", URLString: (url?.string ?? URLString), parameters: parameters, isBody: true)
    }

    /**
     Text - Join strings
     
     - parameter joinStrings: (body)  (optional)
     - parameter apiResponseQueue: The queue on which api response is dispatched.
     - parameter completion: completion handler to receive the data and the error objects
     */
    open class func joinStrings(joinStrings: InputJoinStrings? = nil, apiResponseQueue: DispatchQueue = OpenAPIClientAPI.apiResponseQueue, completion: @escaping ((_ data: OutputString?,_ error: Error?) -> Void)) {
        joinStringsWithRequestBuilder(joinStrings: joinStrings).execute(apiResponseQueue) { result -> Void in
            switch result {
            case let .success(response):
                completion(response.body, nil)
            case let .failure(error):
                completion(nil, error)
            }
        }
    }

    /**
     Text - Join strings
     - POST /JoinStrings
     - Join a collection of strings
     - API Key:
       - type: apiKey X-IBM-Client-Id 
       - name: apiKeyHeader
     - parameter joinStrings: (body)  (optional)
     - returns: RequestBuilder<OutputString> 
     */
    open class func joinStringsWithRequestBuilder(joinStrings: InputJoinStrings? = nil) -> RequestBuilder<OutputString> {
        let path = "/JoinStrings"
        let URLString = OpenAPIClientAPI.basePath + path
        let parameters = JSONEncodingHelper.encodingParameters(forEncodableObject: joinStrings)

        let url = URLComponents(string: URLString)

        let requestBuilder: RequestBuilder<OutputString>.Type = OpenAPIClientAPI.requestBuilderFactory.getBuilder()

        return requestBuilder.init(method: "POST", URLString: (url?.string ?? URLString), parameters: parameters, isBody: true)
    }

    /**
     Text - Redact string
     
     - parameter redactString: (body)  (optional)
     - parameter apiResponseQueue: The queue on which api response is dispatched.
     - parameter completion: completion handler to receive the data and the error objects
     */
    open class func redactString(redactString: InputRedactString? = nil, apiResponseQueue: DispatchQueue = OpenAPIClientAPI.apiResponseQueue, completion: @escaping ((_ data: OutputString?,_ error: Error?) -> Void)) {
        redactStringWithRequestBuilder(redactString: redactString).execute(apiResponseQueue) { result -> Void in
            switch result {
            case let .success(response):
                completion(response.body, nil)
            case let .failure(error):
                completion(nil, error)
            }
        }
    }

    /**
     Text - Redact string
     - POST /RedactString
     - Redact a strng containing sensitive content
     - API Key:
       - type: apiKey X-IBM-Client-Id 
       - name: apiKeyHeader
     - parameter redactString: (body)  (optional)
     - returns: RequestBuilder<OutputString> 
     */
    open class func redactStringWithRequestBuilder(redactString: InputRedactString? = nil) -> RequestBuilder<OutputString> {
        let path = "/RedactString"
        let URLString = OpenAPIClientAPI.basePath + path
        let parameters = JSONEncodingHelper.encodingParameters(forEncodableObject: redactString)

        let url = URLComponents(string: URLString)

        let requestBuilder: RequestBuilder<OutputString>.Type = OpenAPIClientAPI.requestBuilderFactory.getBuilder()

        return requestBuilder.init(method: "POST", URLString: (url?.string ?? URLString), parameters: parameters, isBody: true)
    }

    /**
     Text - Replace string
     
     - parameter replaceString: (body)  (optional)
     - parameter apiResponseQueue: The queue on which api response is dispatched.
     - parameter completion: completion handler to receive the data and the error objects
     */
    open class func replaceString(replaceString: InputReplaceString? = nil, apiResponseQueue: DispatchQueue = OpenAPIClientAPI.apiResponseQueue, completion: @escaping ((_ data: OutputString?,_ error: Error?) -> Void)) {
        replaceStringWithRequestBuilder(replaceString: replaceString).execute(apiResponseQueue) { result -> Void in
            switch result {
            case let .success(response):
                completion(response.body, nil)
            case let .failure(error):
                completion(nil, error)
            }
        }
    }

    /**
     Text - Replace string
     - POST /ReplaceString
     - Replace one value with another in a string
     - API Key:
       - type: apiKey X-IBM-Client-Id 
       - name: apiKeyHeader
     - parameter replaceString: (body)  (optional)
     - returns: RequestBuilder<OutputString> 
     */
    open class func replaceStringWithRequestBuilder(replaceString: InputReplaceString? = nil) -> RequestBuilder<OutputString> {
        let path = "/ReplaceString"
        let URLString = OpenAPIClientAPI.basePath + path
        let parameters = JSONEncodingHelper.encodingParameters(forEncodableObject: replaceString)

        let url = URLComponents(string: URLString)

        let requestBuilder: RequestBuilder<OutputString>.Type = OpenAPIClientAPI.requestBuilderFactory.getBuilder()

        return requestBuilder.init(method: "POST", URLString: (url?.string ?? URLString), parameters: parameters, isBody: true)
    }

    /**
     Text - Shorten hyperlink
     
     - parameter stringInput: (body)  (optional)
     - parameter apiResponseQueue: The queue on which api response is dispatched.
     - parameter completion: completion handler to receive the data and the error objects
     */
    open class func shortenLink(stringInput: InlineObject1? = nil, apiResponseQueue: DispatchQueue = OpenAPIClientAPI.apiResponseQueue, completion: @escaping ((_ data: OutputString?,_ error: Error?) -> Void)) {
        shortenLinkWithRequestBuilder(stringInput: stringInput).execute(apiResponseQueue) { result -> Void in
            switch result {
            case let .success(response):
                completion(response.body, nil)
            case let .failure(error):
                completion(nil, error)
            }
        }
    }

    /**
     Text - Shorten hyperlink
     - POST /ShortenLink
     - Generate a simple, short URL from a complex URL
     - API Key:
       - type: apiKey X-IBM-Client-Id 
       - name: apiKeyHeader
     - parameter stringInput: (body)  (optional)
     - returns: RequestBuilder<OutputString> 
     */
    open class func shortenLinkWithRequestBuilder(stringInput: InlineObject1? = nil) -> RequestBuilder<OutputString> {
        let path = "/ShortenLink"
        let URLString = OpenAPIClientAPI.basePath + path
        let parameters = JSONEncodingHelper.encodingParameters(forEncodableObject: stringInput)

        let url = URLComponents(string: URLString)

        let requestBuilder: RequestBuilder<OutputString>.Type = OpenAPIClientAPI.requestBuilderFactory.getBuilder()

        return requestBuilder.init(method: "POST", URLString: (url?.string ?? URLString), parameters: parameters, isBody: true)
    }

    /**
     * enum for parameter language
     */
    public enum Language_speechToText: String, CaseIterable {
        case arabicBahrain = "Arabic (Bahrain)"
        case arabicEgypt = "Arabic (Egypt)"
        case arabicIraq = "Arabic (Iraq)"
        case arabicJordan = "Arabic (Jordan)"
        case arabicKuwait = "Arabic (Kuwait)"
        case arabicLebanon = "Arabic (Lebanon)"
        case arabicOman = "Arabic (Oman)"
        case arabicQatar = "Arabic (Qatar)"
        case arabicSaudiArabia = "Arabic (Saudi Arabia)"
        case arabicSyria = "Arabic (Syria)"
        case arabicUnitedArabEmirates = "Arabic (United Arab Emirates)"
        case bulgarianBulgaria = "Bulgarian (Bulgaria)"
        case catalanSpain = "Catalan (Spain)"
        case chineseCantonese,Traditional = "Chinese (Cantonese, Traditional)"
        case chineseMandarin,Simplified = "Chinese (Mandarin, Simplified)"
        case chineseTaiwaneseMandarin = "Chinese (Taiwanese Mandarin)"
        case croatianCroatia = "Croatian (Croatia)"
        case czechCzechRepublic = "Czech (Czech Republic)"
        case danishDenmark = "Danish (Denmark)"
        case dutchNetherlands = "Dutch (Netherlands)"
        case englishAustralia = "English (Australia)"
        case englishCanada = "English (Canada)"
        case englishHongKong = "English (Hong Kong)"
        case englishIndia = "English (India)"
        case englishIreland = "English (Ireland)"
        case englishNewZealand = "English (New Zealand)"
        case englishPhilippines = "English (Philippines)"
        case englishSingapore = "English (Singapore)"
        case englishSouthAfrica = "English (South Africa)"
        case englishUnitedKingdom = "English (United Kingdom)"
        case englishUnitedStates = "English (United States)"
        case estonianEstonia = "Estonian(Estonia)"
        case finnishFinland = "Finnish (Finland)"
        case frenchCanada = "French (Canada)"
        case frenchFrance = "French (France)"
        case germanGermany = "German (Germany)"
        case greekGreece = "Greek (Greece)"
        case gujaratiIndian = "Gujarati (Indian)"
        case hindiIndia = "Hindi (India)"
        case hungarianHungary = "Hungarian (Hungary)"
        case irishIreland = "Irish(Ireland)"
        case italianItaly = "Italian (Italy)"
        case japaneseJapan = "Japanese (Japan)"
        case koreanKorea = "Korean (Korea)"
        case latvianLatvia = "Latvian (Latvia)"
        case lithuanianLithuania = "Lithuanian (Lithuania)"
        case malteseMalta = "Maltese(Malta)"
        case marathiIndia = "Marathi (India)"
        case norwegianNorway = "Norwegian (Norway)"
        case polishPoland = "Polish (Poland)"
        case portugueseBrazil = "Portuguese (Brazil)"
        case portuguesePortugal = "Portuguese (Portugal)"
        case romanianRomania = "Romanian (Romania)"
        case russianRussia = "Russian (Russia)"
        case slovakSlovakia = "Slovak (Slovakia)"
        case slovenianSlovenia = "Slovenian (Slovenia)"
        case spanishArgentina = "Spanish (Argentina)"
        case spanishBolivia = "Spanish (Bolivia)"
        case spanishChile = "Spanish (Chile)"
        case spanishColombia = "Spanish (Colombia)"
        case spanishCostaRica = "Spanish (Costa Rica)"
        case spanishCuba = "Spanish (Cuba)"
        case spanishDominicanRepublic = "Spanish (Dominican Republic)"
        case spanishEcuador = "Spanish (Ecuador)"
        case spanishElSalvador = "Spanish (El Salvador)"
        case spanishGuatemala = "Spanish (Guatemala)"
        case spanishHonduras = "Spanish (Honduras)"
        case spanishMexico = "Spanish (Mexico)"
        case spanishNicaragua = "Spanish (Nicaragua)"
        case spanishPanama = "Spanish (Panama)"
        case spanishParaguay = "Spanish (Paraguay)"
        case spanishPeru = "Spanish (Peru)"
        case spanishPuertoRico = "Spanish (Puerto Rico)"
        case spanishSpain = "Spanish (Spain)"
        case spanishUruguay = "Spanish (Uruguay)"
        case spanishUsa = "Spanish (USA)"
        case spanishVenezuela = "Spanish (Venezuela)"
        case swedishSweden = "Swedish (Sweden)"
        case tamilIndia = "Tamil (India)"
        case teluguIndia = "Telugu (India)"
        case thaiThailand = "Thai (Thailand)"
        case turkishTurkey = "Turkish (Turkey)"
    }

    /**
     Text - Speech to Text
     
     - parameter language: (form) Language of audio input 
     - parameter file: (form) Source audio file (WAV, MP3, AAC, M4A) 
     - parameter apiResponseQueue: The queue on which api response is dispatched.
     - parameter completion: completion handler to receive the data and the error objects
     */
    open class func speechToText(language: Language_speechToText, file: URL, apiResponseQueue: DispatchQueue = OpenAPIClientAPI.apiResponseQueue, completion: @escaping ((_ data: OutputString?,_ error: Error?) -> Void)) {
        speechToTextWithRequestBuilder(language: language, file: file).execute(apiResponseQueue) { result -> Void in
            switch result {
            case let .success(response):
                completion(response.body, nil)
            case let .failure(error):
                completion(nil, error)
            }
        }
    }

    /**
     Text - Speech to Text
     - POST /SpeechToText
     - Convert audio file to text (10MB limit)
     - API Key:
       - type: apiKey X-IBM-Client-Id 
       - name: apiKeyHeader
     - parameter language: (form) Language of audio input 
     - parameter file: (form) Source audio file (WAV, MP3, AAC, M4A) 
     - returns: RequestBuilder<OutputString> 
     */
    open class func speechToTextWithRequestBuilder(language: Language_speechToText, file: URL) -> RequestBuilder<OutputString> {
        let path = "/SpeechToText"
        let URLString = OpenAPIClientAPI.basePath + path
        let formParams: [String:Any?] = [
            "language": language.encodeToJSON(),
            "file": file.encodeToJSON()
        ]

        let nonNullParameters = APIHelper.rejectNil(formParams)
        let parameters = APIHelper.convertBoolToString(nonNullParameters)
        
        let url = URLComponents(string: URLString)

        let requestBuilder: RequestBuilder<OutputString>.Type = OpenAPIClientAPI.requestBuilderFactory.getBuilder()

        return requestBuilder.init(method: "POST", URLString: (url?.string ?? URLString), parameters: parameters, isBody: false)
    }

    /**
     Text - Split string
     
     - parameter splitString: (body)  (optional)
     - parameter apiResponseQueue: The queue on which api response is dispatched.
     - parameter completion: completion handler to receive the data and the error objects
     */
    open class func splitString(splitString: InputSplitString? = nil, apiResponseQueue: DispatchQueue = OpenAPIClientAPI.apiResponseQueue, completion: @escaping ((_ data: OutputStringArray?,_ error: Error?) -> Void)) {
        splitStringWithRequestBuilder(splitString: splitString).execute(apiResponseQueue) { result -> Void in
            switch result {
            case let .success(response):
                completion(response.body, nil)
            case let .failure(error):
                completion(nil, error)
            }
        }
    }

    /**
     Text - Split string
     - POST /SplitString
     - Split a string based upon one or more characters
     - API Key:
       - type: apiKey X-IBM-Client-Id 
       - name: apiKeyHeader
     - parameter splitString: (body)  (optional)
     - returns: RequestBuilder<OutputStringArray> 
     */
    open class func splitStringWithRequestBuilder(splitString: InputSplitString? = nil) -> RequestBuilder<OutputStringArray> {
        let path = "/SplitString"
        let URLString = OpenAPIClientAPI.basePath + path
        let parameters = JSONEncodingHelper.encodingParameters(forEncodableObject: splitString)

        let url = URLComponents(string: URLString)

        let requestBuilder: RequestBuilder<OutputStringArray>.Type = OpenAPIClientAPI.requestBuilderFactory.getBuilder()

        return requestBuilder.init(method: "POST", URLString: (url?.string ?? URLString), parameters: parameters, isBody: true)
    }

    /**
     Text - String to File
     
     - parameter inputStringToFile: (body)  (optional)
     - parameter apiResponseQueue: The queue on which api response is dispatched.
     - parameter completion: completion handler to receive the data and the error objects
     */
    open class func stringToFile(inputStringToFile: InputStringToFile? = nil, apiResponseQueue: DispatchQueue = OpenAPIClientAPI.apiResponseQueue, completion: @escaping ((_ data: URL?,_ error: Error?) -> Void)) {
        stringToFileWithRequestBuilder(inputStringToFile: inputStringToFile).execute(apiResponseQueue) { result -> Void in
            switch result {
            case let .success(response):
                completion(response.body, nil)
            case let .failure(error):
                completion(nil, error)
            }
        }
    }

    /**
     Text - String to File
     - POST /StringToFile
     - Convert text string to file
     - API Key:
       - type: apiKey X-IBM-Client-Id 
       - name: apiKeyHeader
     - parameter inputStringToFile: (body)  (optional)
     - returns: RequestBuilder<URL> 
     */
    open class func stringToFileWithRequestBuilder(inputStringToFile: InputStringToFile? = nil) -> RequestBuilder<URL> {
        let path = "/StringToFile"
        let URLString = OpenAPIClientAPI.basePath + path
        let parameters = JSONEncodingHelper.encodingParameters(forEncodableObject: inputStringToFile)

        let url = URLComponents(string: URLString)

        let requestBuilder: RequestBuilder<URL>.Type = OpenAPIClientAPI.requestBuilderFactory.getBuilder()

        return requestBuilder.init(method: "POST", URLString: (url?.string ?? URLString), parameters: parameters, isBody: true)
    }

    /**
     Text - Text to Speech
     
     - parameter textToSpeech: (body)  (optional)
     - parameter apiResponseQueue: The queue on which api response is dispatched.
     - parameter completion: completion handler to receive the data and the error objects
     */
    open class func textToSpeech(textToSpeech: InputTextToSpeech? = nil, apiResponseQueue: DispatchQueue = OpenAPIClientAPI.apiResponseQueue, completion: @escaping ((_ data: URL?,_ error: Error?) -> Void)) {
        textToSpeechWithRequestBuilder(textToSpeech: textToSpeech).execute(apiResponseQueue) { result -> Void in
            switch result {
            case let .success(response):
                completion(response.body, nil)
            case let .failure(error):
                completion(nil, error)
            }
        }
    }

    /**
     Text - Text to Speech
     - POST /TextToSpeech
     - Convert text to an audio file using AI-driven speech synthesis.
     - API Key:
       - type: apiKey X-IBM-Client-Id 
       - name: apiKeyHeader
     - parameter textToSpeech: (body)  (optional)
     - returns: RequestBuilder<URL> 
     */
    open class func textToSpeechWithRequestBuilder(textToSpeech: InputTextToSpeech? = nil) -> RequestBuilder<URL> {
        let path = "/TextToSpeech"
        let URLString = OpenAPIClientAPI.basePath + path
        let parameters = JSONEncodingHelper.encodingParameters(forEncodableObject: textToSpeech)

        let url = URLComponents(string: URLString)

        let requestBuilder: RequestBuilder<URL>.Type = OpenAPIClientAPI.requestBuilderFactory.getBuilder()

        return requestBuilder.init(method: "POST", URLString: (url?.string ?? URLString), parameters: parameters, isBody: true)
    }

    /**
     Text - Translate string
     
     - parameter translateString: (body)  (optional)
     - parameter apiResponseQueue: The queue on which api response is dispatched.
     - parameter completion: completion handler to receive the data and the error objects
     */
    open class func translateString(translateString: InputTranslateString? = nil, apiResponseQueue: DispatchQueue = OpenAPIClientAPI.apiResponseQueue, completion: @escaping ((_ data: OutputString?,_ error: Error?) -> Void)) {
        translateStringWithRequestBuilder(translateString: translateString).execute(apiResponseQueue) { result -> Void in
            switch result {
            case let .success(response):
                completion(response.body, nil)
            case let .failure(error):
                completion(nil, error)
            }
        }
    }

    /**
     Text - Translate string
     - POST /TranslateString
     - Translate a string into a different language
     - API Key:
       - type: apiKey X-IBM-Client-Id 
       - name: apiKeyHeader
     - parameter translateString: (body)  (optional)
     - returns: RequestBuilder<OutputString> 
     */
    open class func translateStringWithRequestBuilder(translateString: InputTranslateString? = nil) -> RequestBuilder<OutputString> {
        let path = "/TranslateString"
        let URLString = OpenAPIClientAPI.basePath + path
        let parameters = JSONEncodingHelper.encodingParameters(forEncodableObject: translateString)

        let url = URLComponents(string: URLString)

        let requestBuilder: RequestBuilder<OutputString>.Type = OpenAPIClientAPI.requestBuilderFactory.getBuilder()

        return requestBuilder.init(method: "POST", URLString: (url?.string ?? URLString), parameters: parameters, isBody: true)
    }

    /**
     Text - Trim string
     
     - parameter trimString: (body)  (optional)
     - parameter apiResponseQueue: The queue on which api response is dispatched.
     - parameter completion: completion handler to receive the data and the error objects
     */
    open class func trimString(trimString: InputTrimString? = nil, apiResponseQueue: DispatchQueue = OpenAPIClientAPI.apiResponseQueue, completion: @escaping ((_ data: OutputString?,_ error: Error?) -> Void)) {
        trimStringWithRequestBuilder(trimString: trimString).execute(apiResponseQueue) { result -> Void in
            switch result {
            case let .success(response):
                completion(response.body, nil)
            case let .failure(error):
                completion(nil, error)
            }
        }
    }

    /**
     Text - Trim string
     - POST /TrimString
     - Trim leading or trailing whitespace from a string
     - API Key:
       - type: apiKey X-IBM-Client-Id 
       - name: apiKeyHeader
     - parameter trimString: (body)  (optional)
     - returns: RequestBuilder<OutputString> 
     */
    open class func trimStringWithRequestBuilder(trimString: InputTrimString? = nil) -> RequestBuilder<OutputString> {
        let path = "/TrimString"
        let URLString = OpenAPIClientAPI.basePath + path
        let parameters = JSONEncodingHelper.encodingParameters(forEncodableObject: trimString)

        let url = URLComponents(string: URLString)

        let requestBuilder: RequestBuilder<OutputString>.Type = OpenAPIClientAPI.requestBuilderFactory.getBuilder()

        return requestBuilder.init(method: "POST", URLString: (url?.string ?? URLString), parameters: parameters, isBody: true)
    }

    /**
     Text - Decode URL
     
     - parameter stringInput: (body)  (optional)
     - parameter apiResponseQueue: The queue on which api response is dispatched.
     - parameter completion: completion handler to receive the data and the error objects
     */
    open class func urlDecode(stringInput: InlineObject2? = nil, apiResponseQueue: DispatchQueue = OpenAPIClientAPI.apiResponseQueue, completion: @escaping ((_ data: OutputString?,_ error: Error?) -> Void)) {
        urlDecodeWithRequestBuilder(stringInput: stringInput).execute(apiResponseQueue) { result -> Void in
            switch result {
            case let .success(response):
                completion(response.body, nil)
            case let .failure(error):
                completion(nil, error)
            }
        }
    }

    /**
     Text - Decode URL
     - POST /URLDecode
     - Decode an encoded URL
     - API Key:
       - type: apiKey X-IBM-Client-Id 
       - name: apiKeyHeader
     - parameter stringInput: (body)  (optional)
     - returns: RequestBuilder<OutputString> 
     */
    open class func urlDecodeWithRequestBuilder(stringInput: InlineObject2? = nil) -> RequestBuilder<OutputString> {
        let path = "/URLDecode"
        let URLString = OpenAPIClientAPI.basePath + path
        let parameters = JSONEncodingHelper.encodingParameters(forEncodableObject: stringInput)

        let url = URLComponents(string: URLString)

        let requestBuilder: RequestBuilder<OutputString>.Type = OpenAPIClientAPI.requestBuilderFactory.getBuilder()

        return requestBuilder.init(method: "POST", URLString: (url?.string ?? URLString), parameters: parameters, isBody: true)
    }

    /**
     Text - Encode URL
     
     - parameter stringInput: (body)  (optional)
     - parameter apiResponseQueue: The queue on which api response is dispatched.
     - parameter completion: completion handler to receive the data and the error objects
     */
    open class func urlEncode(stringInput: InputString? = nil, apiResponseQueue: DispatchQueue = OpenAPIClientAPI.apiResponseQueue, completion: @escaping ((_ data: OutputString?,_ error: Error?) -> Void)) {
        urlEncodeWithRequestBuilder(stringInput: stringInput).execute(apiResponseQueue) { result -> Void in
            switch result {
            case let .success(response):
                completion(response.body, nil)
            case let .failure(error):
                completion(nil, error)
            }
        }
    }

    /**
     Text - Encode URL
     - POST /URLEncode
     - Generate an encoded string from a complex hyperlink
     - API Key:
       - type: apiKey X-IBM-Client-Id 
       - name: apiKeyHeader
     - parameter stringInput: (body)  (optional)
     - returns: RequestBuilder<OutputString> 
     */
    open class func urlEncodeWithRequestBuilder(stringInput: InputString? = nil) -> RequestBuilder<OutputString> {
        let path = "/URLEncode"
        let URLString = OpenAPIClientAPI.basePath + path
        let parameters = JSONEncodingHelper.encodingParameters(forEncodableObject: stringInput)

        let url = URLComponents(string: URLString)

        let requestBuilder: RequestBuilder<OutputString>.Type = OpenAPIClientAPI.requestBuilderFactory.getBuilder()

        return requestBuilder.init(method: "POST", URLString: (url?.string ?? URLString), parameters: parameters, isBody: true)
    }

    /**
     Text - Validate email
     
     - parameter stringInput: (body)  (optional)
     - parameter apiResponseQueue: The queue on which api response is dispatched.
     - parameter completion: completion handler to receive the data and the error objects
     */
    open class func validateEmail(stringInput: InlineObject3? = nil, apiResponseQueue: DispatchQueue = OpenAPIClientAPI.apiResponseQueue, completion: @escaping ((_ data: OutputString?,_ error: Error?) -> Void)) {
        validateEmailWithRequestBuilder(stringInput: stringInput).execute(apiResponseQueue) { result -> Void in
            switch result {
            case let .success(response):
                completion(response.body, nil)
            case let .failure(error):
                completion(nil, error)
            }
        }
    }

    /**
     Text - Validate email
     - POST /ValidateEmail
     - Determine if an email address is valid
     - API Key:
       - type: apiKey X-IBM-Client-Id 
       - name: apiKeyHeader
     - parameter stringInput: (body)  (optional)
     - returns: RequestBuilder<OutputString> 
     */
    open class func validateEmailWithRequestBuilder(stringInput: InlineObject3? = nil) -> RequestBuilder<OutputString> {
        let path = "/ValidateEmail"
        let URLString = OpenAPIClientAPI.basePath + path
        let parameters = JSONEncodingHelper.encodingParameters(forEncodableObject: stringInput)

        let url = URLComponents(string: URLString)

        let requestBuilder: RequestBuilder<OutputString>.Type = OpenAPIClientAPI.requestBuilderFactory.getBuilder()

        return requestBuilder.init(method: "POST", URLString: (url?.string ?? URLString), parameters: parameters, isBody: true)
    }

    /**
     Text - Verify hash
     
     - parameter verifyHash: (body)  (optional)
     - parameter apiResponseQueue: The queue on which api response is dispatched.
     - parameter completion: completion handler to receive the data and the error objects
     */
    open class func verifyHash(verifyHash: InputVerifyHash? = nil, apiResponseQueue: DispatchQueue = OpenAPIClientAPI.apiResponseQueue, completion: @escaping ((_ data: OutputBoolean?,_ error: Error?) -> Void)) {
        verifyHashWithRequestBuilder(verifyHash: verifyHash).execute(apiResponseQueue) { result -> Void in
            switch result {
            case let .success(response):
                completion(response.body, nil)
            case let .failure(error):
                completion(nil, error)
            }
        }
    }

    /**
     Text - Verify hash
     - POST /VerifyHash
     - Verify a hashed value against the original source string
     - API Key:
       - type: apiKey X-IBM-Client-Id 
       - name: apiKeyHeader
     - parameter verifyHash: (body)  (optional)
     - returns: RequestBuilder<OutputBoolean> 
     */
    open class func verifyHashWithRequestBuilder(verifyHash: InputVerifyHash? = nil) -> RequestBuilder<OutputBoolean> {
        let path = "/VerifyHash"
        let URLString = OpenAPIClientAPI.basePath + path
        let parameters = JSONEncodingHelper.encodingParameters(forEncodableObject: verifyHash)

        let url = URLComponents(string: URLString)

        let requestBuilder: RequestBuilder<OutputBoolean>.Type = OpenAPIClientAPI.requestBuilderFactory.getBuilder()

        return requestBuilder.init(method: "POST", URLString: (url?.string ?? URLString), parameters: parameters, isBody: true)
    }

}
