/*
 * PowerTools Developer
 * Apptigent PowerTools Developer Edition is a powerful suite of API endpoints for custom applications running on any stack. Manipulate text, modify collections, format dates and times, convert currency, perform advanced mathematical calculations, shorten URL's, encode strings, convert text to speech, translate content into multiple languages, process images, and more. PowerTools is the ultimate developer toolkit.
 *
 * The version of the OpenAPI document: 2021.1.01
 * Contact: support@apptigent.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package org.openapitools.client.model;

import java.util.Objects;
import java.util.Arrays;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import io.swagger.annotations.ApiModel;
import io.swagger.annotations.ApiModelProperty;
import java.io.IOException;
import java.util.ArrayList;
import java.util.List;

/**
 * InputCollectionFilter
 */
@javax.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen", date = "2021-01-21T09:13:09.005-06:00[America/Chicago]")
public class InputCollectionFilter {
  public static final String SERIALIZED_NAME_INPUT = "input";
  @SerializedName(SERIALIZED_NAME_INPUT)
  private List<String> input = new ArrayList<String>();

  /**
   * Match type
   */
  @JsonAdapter(MatchEnum.Adapter.class)
  public enum MatchEnum {
    ANY("Any"),
    
    ALL("All"),
    
    NONE("None");

    private String value;

    MatchEnum(String value) {
      this.value = value;
    }

    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }

    public static MatchEnum fromValue(String value) {
      for (MatchEnum b : MatchEnum.values()) {
        if (b.value.equals(value)) {
          return b;
        }
      }
      throw new IllegalArgumentException("Unexpected value '" + value + "'");
    }

    public static class Adapter extends TypeAdapter<MatchEnum> {
      @Override
      public void write(final JsonWriter jsonWriter, final MatchEnum enumeration) throws IOException {
        jsonWriter.value(enumeration.getValue());
      }

      @Override
      public MatchEnum read(final JsonReader jsonReader) throws IOException {
        String value =  jsonReader.nextString();
        return MatchEnum.fromValue(value);
      }
    }
  }

  public static final String SERIALIZED_NAME_MATCH = "match";
  @SerializedName(SERIALIZED_NAME_MATCH)
  private MatchEnum match = MatchEnum.ANY;

  public static final String SERIALIZED_NAME_KEYWORDS = "keywords";
  @SerializedName(SERIALIZED_NAME_KEYWORDS)
  private String keywords;


  public InputCollectionFilter input(List<String> input) {
    
    this.input = input;
    return this;
  }

  public InputCollectionFilter addInputItem(String inputItem) {
    this.input.add(inputItem);
    return this;
  }

   /**
   * Collection of strings to filter
   * @return input
  **/
  @ApiModelProperty(required = true, value = "Collection of strings to filter")

  public List<String> getInput() {
    return input;
  }


  public void setInput(List<String> input) {
    this.input = input;
  }


  public InputCollectionFilter match(MatchEnum match) {
    
    this.match = match;
    return this;
  }

   /**
   * Match type
   * @return match
  **/
  @ApiModelProperty(required = true, value = "Match type")

  public MatchEnum getMatch() {
    return match;
  }


  public void setMatch(MatchEnum match) {
    this.match = match;
  }


  public InputCollectionFilter keywords(String keywords) {
    
    this.keywords = keywords;
    return this;
  }

   /**
   * Keywords (separate multiple values with commas)
   * @return keywords
  **/
  @ApiModelProperty(required = true, value = "Keywords (separate multiple values with commas)")

  public String getKeywords() {
    return keywords;
  }


  public void setKeywords(String keywords) {
    this.keywords = keywords;
  }


  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    InputCollectionFilter inputCollectionFilter = (InputCollectionFilter) o;
    return Objects.equals(this.input, inputCollectionFilter.input) &&
        Objects.equals(this.match, inputCollectionFilter.match) &&
        Objects.equals(this.keywords, inputCollectionFilter.keywords);
  }

  @Override
  public int hashCode() {
    return Objects.hash(input, match, keywords);
  }


  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class InputCollectionFilter {\n");
    sb.append("    input: ").append(toIndentedString(input)).append("\n");
    sb.append("    match: ").append(toIndentedString(match)).append("\n");
    sb.append("    keywords: ").append(toIndentedString(keywords)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }

}

